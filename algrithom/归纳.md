## 贪心

### （1）选择最多的区间

##### 解法

在可选的区间（与已选区间无重合）的集合中选择区间右端点最小的区间

##### 最优证明

(1) 与其他选择方案相比，该算法的选择方案在选取了相同数量的更早开始的工作时，其最终结束时间不会比其他方案的更晚。

(2) 所以，不存在选取更多工作的选择方案。

> 说实话，这个证明我觉得没啥道理。书上提示说可以用归纳法和反证法证明。

##### 示例

（1）有n项工作，每项工作分别在si时间开始，在ti时间结束。对于每项工作，你都可以选择参与与否。如果选择了参与，那么自始至终都必须全程参与。此外，参与工作的时间段不能重叠（即使是开始的瞬间和结束的瞬间的重叠也是不允许的)。

### （2）图的最短路问题

##### 解法

迪杰斯特拉最短路算法

### （3）字典序最小问题

##### 问题描述

给定长度为N的字符串S，要构造一个长度为N的字符串T。起初，T是一个空串，随后反复进行下列任意操作。

1. 从S的头部删除一个字符，加到T的尾部
2. 从S的尾部删除一个字符，加到T的尾部目标是要构造字典序R尽可能小的字符串T。

目标是要构造字典序尽可能小的字符串T。

##### 解法

比较S头尾的字符的字典序就好，**细节在于头尾相同时，继续比较头尾相邻的字符**

## 动态规划

### 动态规划特别专题一、背包问题

#### 0-1 背包

##### 基本的解法

```
dp[i][j] : 从前i件物品（含第i件，从0开始）中选出几件，总重量不超过j的最大价值
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]) if j >= weight[i]
dp = {0}
for i = 0:weight.size
	for j = 1:W
		if j >= weight[i] then
			dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
		end
	endloop
endloop
```

在这种解法中，对于重量下标 j 的遍历一定是从小往大的，因为dp[i][j\]的计算依赖于前面下标小于 j 的结果。

##### 空间优化

考虑到`dp[i][j]`的计算只和`dp[i-1][k] k = 0:W`有关，那么可以利用滚动数组进行空间优化

```
dp[i] : 前k件物品中总重量不超过j的最大价值
for i = 0:weight.size
	for j = W:1
        if j >= weight[i] then
        	dp[j] = max(dp[j], dp[j-weight[i]]+value[i])
        end
    endloop
endloop		
```

> Notice
>
> 这个地方对于 j 的遍历只能从大到小

#### 完全背包

完全背包指每样物品可以拿任意多个

##### 基本解法

```
dp[i][j] : 从前i件物品（含第i件，从0开始）中选出几件，总重量不超过j的最大价值
dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weight[i]]+k*value[i]) while j >= k*weight[i]
dp = {0}
for i = 0:weight.size
	for j = 1:W
		for k = 1:quality[i] 
			if j >= k*weight[i] then
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weight[i]]+k*value[i]))
			end
		end
	endloop
endloop
```

本质上和01背包问题的原理是一样的，只不过01背包只考虑0和1两种情况

##### 时间优化

上述解法存在重复计算，导致时间复杂度过大，原因在于：每取一个 j 值，都会计算一遍`dp[i-1][j-k*weight[i]]`

所以，一种优化的思路在于如何利用上次计算的结果，避免重复计算

从状态转移方程入手

```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weight[i]]+k*value[i])
= max(dp[i-1][j], max(dp[i-1][j-weight[i]-k*weight[i]]+value[i]+k*value[i])) 
= max(dp[i-1][j], dp[i][j-weight[i]]+value[i])
```

##### 空间优化

在时间优化的基础之上我们可以进行空间优化，依然是利用滚动数组。不过与01背包滚动数组的区别在于，数组下标应从小到大进行遍历

##### 转换为01背包

因为总容量有限，所以每种物品最多拿`floor(W/weight[i])`个，这样就可以转换为01背包处理

#### 多重背包

完全背包指每样物品可以拿任意多个，这里加一个限制条件：每样物品只有有限个。

##### 基本解法

转换为01背包问题

关于优化，也可以仿照完全背包问题时间优化的思路

```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*weight[i]]+k*value[i]) while k=1:quality[i] j >= k*weight[i] 
= max(dp[i-1][j], max(dp[i-1][j-weight[i]-k*weight[i]]+value[i]+k*value[i])) while k=0:quality[i]-1 j>=(k+1)*weight[i] 
= max(dp[i-1][j], dp[i][j-weight[i]]+value[i]) --quality[i] while quality[i]>0
```

> Notice
>
> 在完全背包问题中，这个变形无论何时都成立，但是在有限制条件下，**这个变形对于一个物品而言只能执行该物品的数量那么多次**

如果利用滚动数组进行空间优化，我们就不得不处理状态转移方程不一定满足的条件了，而处理这个条件则会带来很多麻烦，而且效率并不一定比对应的01背包问题的滚动数组简单

#### 最长公共子序列

##### 问题描述

已知两个字符串，求其最长相同子序列的长度。子序列的是从字符串中抽取出的一系列字符，保留这些字符的相对顺序，这些字符在字符串中不一定相邻。

##### 解法

思路是：两个字符串的最长公共子序列可以通过求出字符串的子串求出来。这样就可以化解问题。

状态转移方程

![image-20220313114827966](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220313114827966.png)

注意到`dp[i+1][j+1]`只需要`dp[i][j]`, `dp[i+1][j]`, `dp[i][j+1]`就可以判断。因此，在具体的算法实现的时候，既可以采用递归由上至下地解决问题，还可以采用更加节省空间和时间的做法：从小往大地，求出`dp[i][j]`。

#### 划分数问题

问题描述

n个无差别物品，分成不超过m组，有多少种分法

##  数据结构

### 优先队列

实际上就是大小根堆。优先队列具有两个性质

1. 加入元素的时间复杂度为对数（插在末尾再调整）
2. 取出最大（或者最小）元素的时间复杂度为常数

#### 卡车加油问题

问题描述

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220319235144452.png" alt="image-20220319235144452" style="zoom:67%;" />

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220319235206812.png" alt="image-20220319235206812" style="zoom:67%;" />

解决思路

首先变换一下思路，我们认为：只要卡车经过过这个加油站，那么在此后的任何时间里，都可以认为卡车在这个站加过油。既然要求最少的次数，所以我们希望在每次燃油耗尽的时候再加油，并且是在加油量最大的站加油。

因此，具体的解法是：先不给卡车加油，当卡车经过某个加油站时，记录所经过的加油站，当卡车燃油耗尽时，在记录的加油站中选择加油量最大的加油站加油，然后消去记录，重复执行这个过程，直到到达目的地（那么返回加油次数），否则当未到达目的地而燃油耗尽且无记录的加油站，则返回-1 。

编码的时候，可以运用到优先队列，利用其线性时间复杂度的求最值的特性。

### 图

#### 最短路问题

Bellman-Ford算法

Dijkstra 算法

#### 最小生成树问题

Prim 算法

不断加入新的点，该点具有与集合中的点的最小的边权值

Kruscal算法

不断加入最小权值的边，不形成圈的前提下

#### 农夫养牛问题

问题描述

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220320165220316.png" alt="image-20220320165220316" style="zoom: 80%;" />

注意这个问题是如何转化为图论问题的

### 并查集

## 常用技巧

### 二分搜索

#### 求最值问题

思路是：不断缩小最值的取值范围，最后找到这个最值，或者逼近这个最值。

##### 例题

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220321171248962.png" alt="image-20220321171248962" style="zoom:80%;" />

思路

设每条绳子长 X，然后对X在（0，inf）范围内进行二分搜索，区间选取的条件是X是否满足约束条件

> 二分搜索结束条件一般是区间长度小于某个值，此时要注意浮点数运算存在误差，小心由于区间长度条件过小而由于误差导致的死循环

最大化平均值

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220321175127864.png" alt="image-20220321175127864" style="zoom:80%;" />

解法

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220321175206151.png" alt="image-20220321175206151" style="zoom:80%;" />

### 滑动窗口（尺取法）

最短

### 其他技巧

### 反转问题

#### 一维反转

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220323191103240.png" alt="image-20220323191103240" style="zoom:80%;" />

##### 基本的解法

可以先固定一个K值，然后测试这个K的情况下最少次数，然后比较各个K所对应的最小值。注意到反转的前后顺序对结果并不影响。最左边的向后的牛一定是要转的，所以不妨先从最左边要转的牛进行旋转，然后接着从下一个需要转的牛再转，如此往复，直到剩下还未遍历的牛的数目小于K，若最后K-1头牛中有需要转的，说明这个K行不通。

> 本质上来说这个解法并没有什么巧妙的地方

#### 二维反转

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220323193033265.png" alt="image-20220323193033265" style="zoom:80%;" />



#### 集合的bitmap表示

当集合元素数量比较小时，可以用32位整型或者64位整型表示

#### 折半枚举

许多问题，涉及到枚举时，如果直接将所有组合完全枚举可能难以实现，那么可以尝试将集合分成两组，分别进行枚举。不做任何优化时，折半枚举的组合数目其实和完全枚举一样，但是折半枚举之所以在有些条件下可以比完全枚举具有更小的时空复杂度，是因为：折半枚举的结果可以进行一些优化，减少集合的一部分的枚举结果的数量，进而减小整体枚举数量。

##### 例子：数值非常大的背包问题

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220323204926799.png" alt="image-20220323204926799" style="zoom:80%;" />

思路

将n个物品拆成两部分，分别进行枚举，对第一组的枚举结果进行筛选<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220323205042320.png" alt="image-20220323205042320" style="zoom:80%;" />

那么就可以减少第二组枚举时匹配的复杂度

## 例题积累

###### 向量最小内积

![image-20220320234356896](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220320234356896.png)

解法

当两个向量分别按照升序和降序排列时，内积最小。

> 注意运算溢出

## 问题

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220320010329165.png" alt="image-20220320010329165" style="zoom:50%;" />

###### 食物链问题的解法还需加深理解，最好是编码实现（页码100）

###### 背包问题中恰好装满这个条件怎么处理，例如零钱兑换问题

###### Bellman ford算法与dijkstra算法有什么异同 

###### bribe the prisoners 问题

###### 一维反转如果可以挨着边界转会怎么样？原来的解法还成立吗

###### 二维反转问题

# TOCODE LIST

- [ ] Huffman code