![image-20211225225913429](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20211225225913429.png)

Java 内存运行时区域中的程序计数器、虚拟机栈、本地方法栈随线程而生灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化），因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

相反，程序运行过程中创建多少对象，需要多少内存是不可知的，所以垃圾收集器重点关注堆内存的回收

###### 判断哪些对象需要被回收

1. 引用计数法

   为对象添加引用计数器，引用一次计数器加一，引用失效即减一，为零时则判断为需要被回收

2. 可达性分析

   通过GC Roots 对象作为起始点，从这些结点开始向下搜索，通过相互引用的关系遍历引用的路径，称为“**引用链**”

![image-20211225230657456](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20211225230657456.png)

> 作为 GC Roots 的节点主要在全局性的引用与执行上下文中，且必须是活的结点

GC 管理的区域是 Java 堆，虚拟机栈、方法区和本地方法栈不被 GC 所管理，因此选用这些区域内引用的对象作为 GC Roots，是不会被 GC 所回收的。

JDK1.2 以前，一个对象只有被引用和没有被引用两种状态。

后来，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。

###### 可达性分析算法

不可达的对象至少要经历两次标记过程

1. 对象在进行可达性分析后发现**没有与 GC Roots 相连接的引用链**，那它将会被第一次标记并且进行一次筛选
2. 当对象没有覆盖 `finalize()` 方法，或者 `finalize()` 方法已经被虚拟机调用过，虚拟机将直接进行第二次标记
3. 如果这个对象被判定为有必要执行 `finalize()` 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行`finalize()` 方法

> 虚拟机会触发这个方法，但并不承诺会等待它运行结束，因为如果一个对象在 `finalize()` 方法中执行缓慢，将很可能会一直阻塞 F-Queue 队列，甚至导致整个内存回收系统崩溃。

> 尝试重载一个类从父类继承来的finalize方法，则在调用System.gc() 以后将会触发finalize()

##### Java 堆永久代的回收

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

1. 回收废弃常量与回收 Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串"abc"已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做"abc"的，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个"abc"常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。
2. **类需要同时满足下面 3 个条件才能算是“无用的类”：
   a. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
   b. 加载该类的 ClassLoader 已经被回收。
   c. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。**

> 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。

## 垃圾收集算法

一共有 4 种：

1. 标记-清除算法
2. 复制算法
3. 标记整理算法
4. 分代收集算法

###### 标记-清除算法

分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象

主要不足有两个：

1. 效率问题，标记和清除两个过程的效率都不高；
2. 空间问题，标记清除之后会产生大量不连续的内存碎

###### 复制算法

将内存分为两个或更多个部分，同时只使用其中的几个或一个部分，垃圾回收时，将存活对象直接复制到未使用的部分，然后将另一个部分直接全部回收

IBM指出将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。同时只使用一块Eden和一块Survivor，回收时将所有存活对象复制到未使用的survivor。

> HotSpot 虚拟机默认 Eden:Survivor = 8:1

如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代

##### 标记-整理算法

复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。老年代一般不能直接选用这种算法

标记过程仍然与“标记-清除”算法一样，但后续步骤是让所有存活的对象都向一端移动，然后**直接清理掉端边界以外的内存**。相当于操作系统中的“**紧凑**”

##### 分代收集算法

当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块并采用不用的垃圾收集算法。

一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

### HotSpot的垃圾回收算法实现

##### 枚举根节点

执行时间的敏感性体现在逐个检查GC Roots与GC停顿（必须停止所有执行线程，以保证引用关系不发生改变）

在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录栈和寄存器中哪些位置是引用。这样， GC 在扫描时就可以直接得知这些信息了。

> 这种OopMap的好处在于不必每次都遍历查找每个GC Roots，而是能够通过计算快速找到这些GC Roots

##### 安全点（Safepoint）

在 OopMap 的协助下，HotSpot 可以快速且准确地完成 GC Roots 枚举，但可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得很高。

实际上，HotSpot 也的确没有为每条指令都生成 OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始 GC ，只有在到达安全点时才能暂停。

### 安全区域（Safe Region）

使用 Safepoint 似乎已经完美地解决了如何进入 GC 的问题，但实际情况却并不一定。Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的Safepoint。但是如果程序不执行就是没有分配 CPU 时间，典型的例子就是线程处于 Sleep 状态或者 Blocked 状态，这时候线程无法响应 JVM 的中断请求，执行到安全点去中断挂起

> 安全区域是指在一段代码片段之中，引用关系不会发生变化。

![image-20211225233418687](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20211225233418687.png)

垃圾收集器如上图

