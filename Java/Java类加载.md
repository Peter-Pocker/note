## Java 类加载机制

### 类加载的时机

- 隐式加载 new 创建类的实例,
- 显式加载：loaderClass,forName等
- 访问类的静态变量，或者为静态变量赋值
- 调用类的静态方法
- 使用反射方式创建某个类或者接口对象的Class对象。
- 初始化某个类的子类
- 直接使用`java.exe`命令来运行某个主类

### 类加载的过程

![image-20211226215142629](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20211226215142629.png)

加载
类加载过程的一个阶段，ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象。

验证
目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。

准备
为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。

解析
这里主要的任务是把常量池中的符号引用替换成直接引用

初始化
这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）

> 类记载器的任务是根据类的全限定名来读取此类的二进制字节流到 JVM 中，然后转换成一个与目标类对象的java.lang.Class 对象的实例，在java 虚拟机提供三种类加载器，引导类加载器，扩展类加载器，系统类加载器。

### 类加载的方法

#### 从文件加载 initializeFromArchive

```java
// Defined in class VM
public static native void initializeFromArchive(Class<?> c);
```

最典型的例子就是 `java.lang.Integer$IntegerCache`类

#### forName和loaderClass区别

`Class.forName`方法得到的class是已经初始化完成的。

`Classloader.loaderClass`方法得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。

### 加载一个类时的程序执行顺序

1. 加载父类（如果父类未加载）

   **初始化父类静态变量与执行父类静态代码块**

   具体执行顺序与代码在文件中的位置有关，也就是说：静态代码块与静态变量初始化是相同优先级的，谁写在前面就先执行谁。这也意味着：先写的静态代码块不能访问位于其后定义和初始化的静态变量

2. 加载子类（如果未加载）

   初始化子类静态变量执行子类静态代码块，原理和父类一样，初始化和代码块优先级一样

3. 执行父类动态代码块与初始化成员变量

   这个地方原理同静态一样，初始化成员变量与动态代码块的优先级都是一样的

4. 执行父类构造函数

5. 执行子类动态代码块与初始化成员变量

6. 执行子类构造函数

### 参考

[Java类加载机制_清风博客-CSDN博客_类加载机制](https://blog.csdn.net/weixin_40236948/article/details/88072698)