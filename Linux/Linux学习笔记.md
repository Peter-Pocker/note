fork 函数如何实现在父子进程中返回不同的值？

fork 本质上是为子进程申请一个空白PCB，并将PCB进行初始化，并将父进程的堆栈，代码，资源等复制一份给子进程。注意，复制的同时包含了复制父进程的上下文（因为调用fork之后，系统会切换到内核态，会执行保护现场）。关键地方来了，fork 不单是复制父进程的上下文，还会将子进程上下文中代表 R0 通用寄存器的值设置为0，而函数返回值是存放在 R0 寄存器中的，所以返回父进程和返回子进程的上下文有区别，故而读到的返回值不同。

什么是系统调用表？

用户进程进行系统调用的时候（system call），系统调用函数会通过系统调用表被翻译为内核函数的函数指针。

什么是 SVC 模式？

操作系统的启动过程？

什么是 HOOK 函数？

内存映射和页表有什么关系？

进程与线程的区别？

堆到底在哪里？

内核线程没有用户上下文，即其进程描述符中的mm域为空。内核线程将直接使用进程的内存描述符

![image-20220118194746745](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220118194746745.png)

什么是文件预读取？

读数据的时候有意地多读取一些本次请求以外的数据。如果对数据的读取是顺序地，那么多读取的这些数据可能很快就会被访问到。

__randomize_layout 是什么？

在 Linux 源代码中，很多包含函数指针的结构体在定义的时候，“} ”之后都会加一个 randomize_layout，这是提示 gcc 编译器：将结构体中的元素随机排布。这样做，主要是出于安全的原因（防范缓冲区溢出攻击等）。当然，如果用户不需要随机化，也可以 声明 no_randomize_layout 进行防止随机化。

什么是“写时拷贝（Copy On Write）”？

在复制的区域将发生改变（例如被写入）的时候才真正地复制其内容到新的区域中。

#### 写缓存

写磁盘时

三种策略

一、不缓存

二、自动更新缓存和磁盘文件（写透缓存）

三、回写（write-back）

写操作直接写到缓存中，磁盘不会立即更新，而是将页标记为“脏”，并加入到脏链表中，并由回写进程周期性地写入磁盘中

#### 页面置换（缓存回收）算法

双链策略

一种修改过的LRU。Linux维护两个链表：活跃与非活跃链表

![image-20220118220309120](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220118220309120.png)

##### 孤儿进程与僵尸进程

重点在于处理僵尸进程。

1.子进程退出时向父进程发出 SIGCHILD 信号，父进程处理该信号。在父进程的信号处理函数中，调用wait或waitpid函数进行处理。

2.如果父进程不断产生僵尸进程，可以向父进程发送 SIGTERM 或 SIGKILL 信号终止父进程，于是所有僵尸进程都成为孤儿进程而被 init 收养，完成回收PCB的工作

##### 0号进程与1号进程

[linux的0号进程和1号进程 - AlanTu - 博客园 (cnblogs.com)](https://www.cnblogs.com/alantu2018/p/8526970.html)

红黑树

[红黑树(一)之 原理和算法详细介绍 - 如果天空不死 - 博客园 (cnblogs.com)](https://www.cnblogs.com/skywang12345/p/3245399.html)

内核栈与用户栈

当用户进程进行系统调用的时候，从用户态陷入内核态，栈基址寄存器修改为内核栈。向内核栈中写入用户栈指针，退出内核态时，向栈基址寄存器中写入用户栈地址

> 需要注意的是，内核态堆栈仅用于内核例程，Linux内核另外为中断提供了单独的硬中断栈和软中断栈

C源程序到可执行文件的过程

预处理、由编译器编译成汇编代码，由汇编器转换为机器码，再由链接器装入引用文件

![image-20220119165312221](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20220119165312221.png)

##### 程序的指令和数据分开原因

一、当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读。这样可以防止程序的指令被有意或无意地改写。

二、对于现代的CPU来说，它们有着极为强大的缓存（Cache）体系。由于缓存在现代的计算机中地位非常重要，所以程序必须尽量提高缓存的命中率。指令区和数据区的分离有利于提高程序的局部性。现代CPU的缓存一般都被设计成数据缓存和指令缓存分离，所以程序的指令和数据被分开存放对CPU的缓存命中率提高有好处。

三、其实也是最重要的原因，就是当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只须要保存一份改程序的指令部分。对于指令这种只读的区域来说是这样，对于其他的只读数据也一样，比如很多程序里面带有的图标、图片、文本等资源也是属于可以共享的。当然每个副本进程的数据区域是不一样的，它们是进程私有的。

##### BSS段有什么？

全局的未初始化变量存在于bss段中，具体体现为一个[占位符](https://so.csdn.net/so/search?q=占位符&spm=1001.2101.3001.7020)；全局的已初始化变量存于data段中；而函数内的自动变量都在栈上分配空间。bss是不占用.exe文件空间的，其内容由操作系统初始化（清零）；而data却需要占用，其内容由程序初始化，因此造成了上述情况。

全局的未初始化变量存在于*.bss*段中，具体体现为一个占位符；全局的已初始化变量存于*.data*段中；而函数内的自动变量都在栈上分配空间。*.bss*是不占用*.exe*文件空间的，其内容由操作系统初始化（清零）；而 *.data* 却需要占用，其内容由程序初始化。

也就是说：

bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。*
**data*（已手动初始化的数据）段则为数据分配空间，数据保存在目标文件中。

数据段包含经过初始化的全局变量以及它们的值。

*BSS*段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零。包含数据段和*BSS*段的整个区段此时通常称为数据区。

### 进程状态

进程描述符中的 `state` 描述了进程当前的状态，有如下 5 种：

1. TASK_RUNNING：进程是可执行的，此时进程要么是正在执行，要么是在运行队列中等待被调度
2. TASK_INTERRUPTIBLE：进程正在睡眠（阻塞），等待条件达成。如果条件达成或者收到信号，进程会被唤醒并且进入可运行状态
3. TASK_UNINTERRUPTIBLE：进程处于不可中断状态，就算信号也无法唤醒，这种状态用的比较少
4. _TASK_TRACED：进程正在被其它进程追踪，通常是为了调试
5. _TASK_STOPPED：进程停止运行，通常是接收到 SIGINT、SIGTSTP 信号的时候

#### fork, vfork, clone 的区别

在fork()之后exec之前两个进程用的是相同的物理空间（内存区），先把页表映射关系建立起来，并不真正将内存拷贝。子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个

vfork是一个过时的应用，vfork也是创建一个子进程，但是子进程共享父进程的空间。在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()。vfork最初是因为fork没有实现COW机制，而很多情况下fork之后会紧接着exec，而exec的执行相当于之前fork复制的空间全部变成了无用功，所以设计了vfork

clone是Linux为创建线程设计的（虽然也可以用clone创建进程）。所以可以说clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、**有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程**等等。

> fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”，如果父子进程一直对这个页面是同一个页面，直到其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。这就是所谓的“写时复制”。

#### 进程的四要素

       （1）有一段程序供其执行（不一定是一个进程所专有的），就像一场戏必须有自己的剧本。
       （2）有自己的专用系统堆栈空间（私有财产）
       （3）有进程控制块（task_struct）（“有身份证，PID”）
       （4）有独立的存储空间。
