##### volatile

与const对立，表示一个变量可能被无法预知的流程更改。提示程序每次访问变量都要从内存中读取而不是从缓存中读取

##### inline

内联函数，用于频繁用到的函数。内联函数与普通函数的不同在于不需要使用到函数栈，减少了函数调用的开销。内联函数实际上相当于在调用的地方进行代码替换。inline产生作用是在定义函数的地方而非声明函数的地方。

##### static

可以修饰变量和函数。将变量修饰为所声明作用域下的静态变量。也就是说，如果在函数中被定义，就只能在这个函数中访问，在函数外定义，就可以在全局访问。

静态变量与全局变量（函数外定义的变量）都存放在静态存储区（联想 BSS 段），而静态存储区是全被置为零的，所以静态存储区的变量都默认为全零。

全局变量被static修饰后，作用域一般情况下只在当前文件。函数中的局部变量被修饰后成为静态局部变量，变量值在函数结束时不被清除。静态变量与全局变量都存储在静态存储区，其主要区别就在于可见性，静态变量只在其被声明的代码块中是可见的。

函数被static修饰后，只在当前文件内可见

**被static修饰的变量并非一定只能在本文件内可见！！！**

###### 访问其他文件静态全局变量的方法

> 先在A.c中定义静态变量 i
>
> `static int i = 1;`
>
> 再在 B.c 中include A.c，再声明静态变量 i
>
> `static int i; // 不要给i赋值，否则会报错 redefinition error`
>
> 于是可以在 B.c 中访问 A.c 中定义的变量 i

全局变量

所有在函数以外定义的变量都是全局变量（main函数也是函数），它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件

C语言代码是从前往后依次执行的，函数定义之后再定义的全局变量在函数中是不可见的。

##### extern

##### far, near, auto

都是基于CPU架构的关键字，代表被修饰的变量或函数不在（在）当前段（程序分段）中

##### typeof

用于获取变量类型，其参数可以是表达式或类型

```c
extern int foo();
typeof(foo()) a; // 此处声明了a是一个int类型，而foo函数并不会被执行
```

typeof构造中的类型名不能包含存储类说明符，如**extern**或**static**。不过允许包含类型限定符，如**const**或**volatile**。